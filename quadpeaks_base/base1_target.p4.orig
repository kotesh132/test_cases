    error {
        NoError,
        PacketTooShort,
        NoMatch,
        StackOutOfBounds,
        OverwritingHeader,
        HeaderTooShort,
        ParserTimeout
    }

    extern packet_in {

        void extract<T>(out T hdr);

        void extract<T>(out T variableSizeHeader,
                        in bit<32> variableFieldSizeInBits);
        
        T lookahead<T>();
        
        void advance(in bit<32> sizeInBits);
        
        bit<32> length();
    }

    extern packet_out {
        void emit<T>(in T hdr);
        void emit<T>(in bool condition, in T data);
    }

    extern void verify(in bool check, in error toSignal);

    @name("NoAction")
    action NoAction() {}

    match_kind {
        exact,
        ternary,
        lpm 
    }

    struct standard_metadata_t {
        bit<8>  ingress_port;
        bit<8>  egress_port;
    }

    struct fwd_metadata_t {
        bit<24> l2ptr;
        bit<24> out_bd;
    }

    struct l3_metadata_t {
        bit<16> lkp_l4_sport;
        bit<16> lkp_l4_dport;
    }

    header ipv4_up_to_ihl_only_h {
        bit<4> version;
        bit<4> ihl;
    }



    header trill_t {
        bit<2> v;
        bit<2> reserved;
        bit<1> m;
        bit<5> oplength;
        bit<6> hopcount;
        bit<16> egrb;
        bit<16> igrb;
    }

    header dce_t{
        bit<10> ftag;
        bit<6> ttl;
    }

    header ivntag_t {
        bit<3> pcp;
        bit<1> de;
        bit<12> src_evid;
        bit<2> rsvd0;
        bit<14> dst_evid;
        bit<16> rsvd;
        bit<16> etherType;
    }

    header cmd_sgt_dgt_t {
        bit<3>  length_sgt;
        bit<13> optiontype_sgt;
        bit<16> sgt;
        bit<3>  length_dgt;
        bit<13> optiontype_dgt;
        bit<16> dgt;
        bit<16> etherType;
    }

    header geneve_t {
        bit<2>  ver;
        bit<6>  optLen;
        bit<1>  oam;
        bit<1>  critical;
        bit<6>  reserved;
        bit<16> protoType;
        bit<24> vni;
        bit<8>  reserved2;
        varbit<1664> options;
    }

    header geneve_up_to_len_t {
        bit<2>  ver;
        bit<6>  optLen;
    }
    header int_shim_int_t {
        bit<8>  type;
        bit<8>  reserved;
        bit<8>  length;
        bit<8>  next_proto;
        bit<2>  ver;
        bit<2>  rep;
        bit<1>  int_c;
        bit<1>  int_e;
        bit<5>  int_r;
        bit<5>  ins_cnt;
        bit<8>  max_hopcnt;
        bit<8>  total_hopcnt;
        bit<16> instr_bitmap;
        bit<16> reserved2;
        varbit<1568> int_metadata;
    }

    header int_shim_int_up_to_len_t {
        bit<8>  type;
        bit<8>  reserved;
        bit<8>  length;
    }
    header nsh24_t{
     
       bit<24> sp;
       bit<8> si;
     
       bit<1> d;
       bit<1> f;
       bit<2> rsvd0;
       bit<12> snid;
       bit <16> sif;
     
       bit<8> rsvd1;
       bit<24> tenant_id;
     
       bit<16> dclass;
       bit<16> sclass;
     
       bit<32> data; 
    }

    header nsh64_t{
     
       bit<24> sp;
       bit<8> si;
     
       bit<1> d;
       bit<1> f;
       bit<2> rsvd0;
       bit<12> snid;
       bit <16> sif;
     
       bit<8> rsvd1;
       bit<24> tenant_id;
     
       bit<16> dclass;
       bit<16> sclass;
     
       bit<32> data;
     
       bit<320> tlv_data;
    }

    header ipv6srh_t {
        bit<8>  next_header;
        bit<8>  hdr_ext_len;
        bit<8> routing_type;
        bit<8>  segments_left;
        bit<8>  first_segment;
        bit<8>  flags;
        bit<16> tag;
        bit<128> segment0;
        varbit<1536> seg_list;
    }

    header ipv6srh_up_to_length_t {
        bit<8>  next_header;
        bit<8>  hdr_ext_len;
    }

    header rocev2_ib_bth_t{
       bit<8> opcode;
       bit<1> se;
       bit<1> m;
       bit<2> padCnt;
       bit<4> tVer;
       bit<16> pKey;
       bit<1> f_r;
       bit<1> b_r;
       bit<6> rsvd0;
       bit<24> destQp;
       bit<1> ack;
       bit<7> rsvd1;
       bit<24> psn;
    }

    header vxlan_gpo_t {
       bit<1> g;
       bit<3> flag_reserved;
       bit<1> i;
       bit<4> flag_reserved2;
       bit<1> d;
       bit<2> flag_reserved3;
       bit<1> a;
       bit<3> flag_reserved4;
       bit<16> grpPolicyId;
       bit<24> vni;
       bit<8> reserved;
    }

    header gtp_base_t {
       bit<3> ver;
       bit<1> protType;
       bit<1> rsvd;
       bit<1> e;
       bit<1> s;
       bit<1> pn;
       bit<8> messageType;
       bit<16> messageLen;
    }

    header gtpv1_t{
      bit<32> teid;
    }

    header gtpv1_ext_t{
      bit<32> teid;
      bit<16> seqNum;
      bit<8> npdu;
      bit<8> nextExtHdr;
    }

    header gtpv2_teid_t{
      bit<32> teid;
      bit<24> seqNum;
      bit<8> spare;
    }
    header gtpv2_t{
      bit<24> seqNum;
      bit<8> spare;
    }

    header ioam_trace_ioam_t {
      bit<8> type;
      bit<8> len;
      bit<8> rsvd;
      bit<8> nextProto;
      bit<16> traceType;
      bit<4> nodeLen;
      bit<5> flags;
      bit<7> maxLen;
      varbit<1568> ioamNodeData; 
    }

    header ioam_up_to_len_t {
      bit<8> type;
      bit<8> len;
    }

    header arp_rarp_t {
        bit<16> hwType;
        bit<16> protoType;
        bit<8>  hwAddrLen;
        bit<8>  protoAddrLen;
        bit<16> opcode;
        bit<48> srcHwAddr;
        bit<32> srcProtoAddr;
        bit<48> dstHwAddr;
        bit<32> dstProtoAddr;
    }

    header cmd_t {
        bit<8> version;
        bit<8> length_cmd;
    }

    header cmd_sgt_t {
        bit<3>  length_sgt;
        bit<13> optiontype_sgt;
        bit<16> sgt;
        bit<16> etherType;
    }

    header erspan2_t {
        bit<4>  ver;
        bit<12> vlan;
        bit<3>  cos;
        bit<2>  en;
        bit<1>  t;
        bit<10> ses;
        bit<12> rsvd;
        bit<20> idx;
    }

    header erspan3_t {
        bit<4>  ver;
        bit<12> vlan;
        bit<3>  cos;
        bit<2>  bso;
        bit<1>  t;
        bit<10> ses;
        bit<32> tstmp;
        bit<16> sgt;
        bit<1>  p;
        bit<5>  ft;
        bit<6>  hwid;
        bit<1>  dir;
        bit<2>  gra;
        bit<1>  opt;
        bit<6>  platfid;
        bit<6>  rsvd;
        bit<20> idx;
        bit<32> tstmp_hi;
    }

    header ethernet_t {
        bit<48> dstAddr;
        bit<48> srcAddr;
        bit<16> etherType;
    }

    header fcoe_t {
        bit<4>  version;
        bit<32> rsvd0;
        bit<32> rsvd1;
        bit<32> rsvd2;
        bit<4>  rsvd3;
        bit<8>  esof;
        bit<8>  rctl;
    }

    header gre_t {
        bit<1>  C;
        bit<1>  R;
        bit<1>  K;
        bit<1>  S;
        bit<1>  s;
        bit<3>  recurse;
        bit<5>  flags;
        bit<3>  ver;
        bit<16> proto;
    }

    header icmp_t {
        bit<16> typeCode;
        bit<16> hdrChecksum;
    }

    header icmpv6_t {
        bit<8>  type_;
        bit<8>  code;
        bit<16> hdrChecksum;
    }

    header ieth_t {
        bit<8>  sof;
        bit<1>  hdr_type;
        bit<1>  ext_hdr;
        bit<2>  l2_fwd_mode;
        bit<2>  l3_fwd_mode;
        bit<14> src_idx;
        bit<14> dst_idx;
        bit<8>  src_chip;
        bit<8>  src_port;
        bit<8>  dst_chip;
        bit<8>  dst_port;
        bit<14> outer_bd;
        bit<14> bd;
        bit<1>  mark;
        bit<1>  span;
        bit<1>  alt_if_profile;
        bit<1>  ip_ttl_bypass;
        bit<1>  src_is_tunnel;
        bit<1>  dst_is_tunnel;
        bit<1>  l2_tunnel;
        bit<1>  sup_tx;
        bit<5>  sup_code;
        bit<4>  tclass;
        bit<1>  src_is_peer;
        bit<8>  pkt_hash;
        bit<16> etherType;
    }

    header ipv4_t {
        bit<4>  version;
        bit<4>  ihl;
        bit<6>  dscp;
        bit<2>  ecn;
        bit<16> totalLen;
        bit<16> identification;
        bit<1>  flag_rsvd;
        bit<1>  flag_noFrag;
        bit<1>  flag_more;
        bit<13> fragOffset;
        bit<8>  ttl;
        bit<8>  protocol;
        bit<16> hdrChecksum;
        bit<32> srcAddr;
        bit<32> dstAddr;
        varbit<320> options;
    }

    header ipv4_up_to_ihl_only_t{
        bit<4>  version;
        bit<4>  ihl;  
    }

    header ipv6_t {
        bit<4>   version;
        bit<6>   dscp;
        bit<2>   ecn;
        bit<20>  flowLabel;
        bit<16>  payloadLen;
        bit<8>   nextHeader;
        bit<8>   hopLimit;
        bit<128> srcAddr;
        bit<128> dstAddr;
    }

    header ipv6_neighbor_discovery_t {
        bit<8>   flags;
        bit<24>  rsvd;
        bit<128> targetAddr;
    }

    header l3l4_arp_t {
        bit<16> hwType;
        bit<16> protoType;
        bit<8>  hwAddrLen;
        bit<8>  protoAddrLen;
        bit<16> opcode;
        bit<48> srcHwAddr;
        bit<32> srcProtoAddr;
        bit<48> dstHwAddr;
        bit<32> dstProtoAddr;
    }

    header l3l4_ipv4_t {
        bit<32> ipv4_sa;
        bit<32> ipv4_da;
        bit<8>  ip_proto;
        bit<8>  ip_ttl;
        bit<6>  ip_dscp;
        bit<2>  ip_ecn;
        bit<16> ip_len;
        bit<1>  ip_opt;
        bit<13> ip_fragOffset;
        bit<1>  ip_flag_more;
        bit<16> l4_sport;
        bit<16> l4_dport;
        bit<8>  tcp_flags;
        bit<1>  tcp_flag_ack;
        bit<1>  tcp_flag_rst;
        bit<1>  ivxlan_flags_nonce;
        bit<1>  ivxlan_flags_locator;
        bit<1>  ivxlan_flags_color;
        bit<1>  ivxlan_flags_ext_fb_lb_tag;
        bit<1>  ivxlan_flags_instance;
        bit<1>  ivxlan_flags_protocol;
        bit<1>  ivxlan_flags_fcn;
        bit<1>  ivxlan_flags_oam;
        bit<1>  ivxlan_nonce_lb;
        bit<1>  ivxlan_nonce_dl;
        bit<1>  ivxlan_nonce_e;
        bit<1>  ivxlan_nonce_sp;
        bit<1>  ivxlan_nonce_dp;
        bit<3>  ivxlan_nonce_dre;
        bit<16> ivxlan_nonce_sclass;
        bit<24> ivxlan_vni;
        bit<4>  erspan_ver;
        bit<10> erspan_ses;
    }

    header l3l4_ipv6_t {
        bit<128> ipv6_sa;
        bit<128> ipv6_da;
        bit<8>   ip_proto;
        bit<8>   ip_ttl;
        bit<6>   ip_dscp;
        bit<2>   ip_ecn;
        bit<16>  ip_len;
        bit<1>   ip_opt;
        bit<13>  ip_fragOffset;
        bit<1>   ip_flag_more;
        bit<16>  l4_sport;
        bit<16>  l4_dport;
        bit<8>   tcp_flags;
        bit<1>   tcp_flag_ack;
        bit<1>   tcp_flag_rst;
        bit<1>   ivxlan_flags_nonce;
        bit<1>   ivxlan_flags_locator;
        bit<1>   ivxlan_flags_color;
        bit<1>   ivxlan_flags_ext_fb_lb_tag;
        bit<1>   ivxlan_flags_instance;
        bit<1>   ivxlan_flags_protocol;
        bit<1>   ivxlan_flags_fcn;
        bit<1>   ivxlan_flags_oam;
        bit<1>   ivxlan_nonce_lb;
        bit<1>   ivxlan_nonce_dl;
        bit<1>   ivxlan_nonce_e;
        bit<1>   ivxlan_nonce_sp;
        bit<1>   ivxlan_nonce_dp;
        bit<3>   ivxlan_nonce_dre;
        bit<16>  ivxlan_nonce_sclass;
        bit<24>  ivxlan_vni;
        bit<4>   erspan_ver;
        bit<10>  erspan_ses;
    }

    header l3l4_nd_t {
        bit<128> ipv6_sa;
        bit<128> ipv6_da;
        bit<8>   ip_proto;
        bit<8>   ip_ttl;
        bit<6>   ip_dscp;
        bit<2>   ip_ecn;
        bit<16>  ip_len;
        bit<1>   ip_opt;
        bit<13>  ip_fragOffset;
        bit<1>   ip_flag_more;
        bit<8>   type_;
        bit<8>   code;
        bit<8>   flags;
        bit<128> targetAddr;
    }

    header vlan_tag_t {
        bit<3>  pcp;
        bit<1>  cfi;
        bit<12> vid;
        bit<16> etherType;
    }

    header tcp_t {
        bit<16> srcPort;
        bit<16> dstPort;
        bit<32> seqNo;
        bit<32> ackNo;
        bit<4>  dataOffset;
        bit<4>  res;
        bit<8>  flags;
        bit<16> window;
        bit<16> checksum;
        bit<16> urgentPtr;
    }

    header timestamp_t {
        bit<48> time;
        bit<16> etherType;
    }

    header udp_t {
        bit<16> srcPort;
        bit<16> dstPort;
        bit<16> length_;
        bit<16> checksum;
    }

    header ipv6_hbh_hel1_t {
        bit<64> options;
    }

    header ipv6_hbh_hel2_t {
        bit<128> options;
    }

    header ipv6_hbh_hel3_t {
        bit<192> options;
    }

    header ipv6_hop_by_hop_t {
        bit<8>  protocol;
        bit<8>  hdr_ext_len;
        bit<16> options01;
        bit<32> options02;
    }

    header ipv6frag_t {
        bit<8>  protocol;
        bit<8>  hdr_ext_len;
        bit<13> fragOffset;
        bit<2>  rsvd;
        bit<1>  flag_more;
        bit<32> id;
    }

    header ivxlan_t {
        bit<1>  flags_nonce;
        bit<1>  flags_locator;
        bit<1>  flags_color;
        bit<1>  flags_ext_fb_lb_tag;
        bit<1>  flags_instance;
        bit<1>  flags_protocol;
        bit<1>  flags_fcn;
        bit<1>  flags_oam;
        bit<1>  nonce_lb;
        bit<1>  nonce_dl;
        bit<1>  nonce_e;
        bit<1>  nonce_sp;
        bit<1>  nonce_dp;
        bit<3>  nonce_dre;
        bit<16> nonce_sclass;
        bit<24> vni;
        bit<1>  lsb_m;
        bit<4>  lsb_vpath;
        bit<3>  lsb_metric;
    }

    header llc_header_t {
        bit<8> dsap;
        bit<8> ssap;
        bit<8> control_;
        bit<24> oui;
    }

    header nsh_base_t {
        bit<2>  version;
        bit<1>  oam;
        bit<1>  context;
        bit<6>  flags;
        bit<6>  length;
        bit<8>  md_type;
        bit<8>  next_proto;
    }
    header nsh_t {
        bit<2>  version;
        bit<1>  oam;
        bit<1>  context;
        bit<6>  flags;
        bit<6>  length;
        bit<8>  md_type;
        bit<8>  next_proto;
        bit<24> spath;
        bit<8> sindex;
    }
    header nsh_context_t {
        bit<32> network_platform;
        bit<32> network_shared;
        bit<32> service_platform;
        bit<32> service_shared;
    }

    header nvgre_t {
        bit<24> tni;
        bit<8>  flow_id;
    }

    header snap_header_t {
        bit<16> type_;
    }

    header vntag_t {
        bit<1>  direction;
        bit<1>  pointer;
        bit<14> destVif;
        bit<1>  looped;
        bit<1>  reserved;
        bit<2>  version;
        bit<12> srcVif;
        bit<16> etherType;
    }

    header vxlan_gpe_t {
        bit<2>  flags_reserved;
        bit<2>  flags_version;
        bit<1>  flags_i;
        bit<1>  flags_p;
        bit<1>  flags_reserved2;
        bit<1>  flags_o;
        bit<16> reserved;
        bit<8>  next_proto;
        bit<24> vni;
        bit<8>  reserved2;
    }

    header vxlan_t {
        bit<8>  flags;
        bit<24> rsvd;
        bit<24> vni;
        bit<8>  rsvd2;
    }

    header mpls_t {
        bit<20> label;
        bit<3>  exp;
        bit<1>  bos;
        bit<8>  ttl;
    }


    struct metadata {
        @name("fwd_metadata") 
        fwd_metadata_t fwd_metadata;
        @name("l3_metadata") 
        l3_metadata_t  l3_metadata;
    }

    struct headers {
        arp_rarp_t                arp_rarp;
        trill_t                   trill;
        dce_t                     dce;
        ivntag_t                  ivntag;
        cmd_t                     cmd;
        cmd_sgt_t                 cmd_sgt;
        cmd_sgt_dgt_t             cmd_sgt_dgt;
        erspan2_t                 erspan2;
        erspan3_t                 erspan3;
        ethernet_t                ethernet;
        fcoe_t                    fcoe;
        geneve_t                  geneve;
        gre_t                     gre;
        icmp_t                    icmp;
        icmpv6_t                  icmpv6;
        ieth_t                    ieth;
        arp_rarp_t                inner_arp_rarp;
        cmd_t                     inner_cmd;
        cmd_sgt_t                 inner_cmd_sgt;
        cmd_sgt_dgt_t             inner_cmd_sgt_dgt;
        ethernet_t                inner_ethernet;
        fcoe_t                    inner_fcoe;
        icmp_t                    inner_icmp;
        icmpv6_t                  inner_icmpv6;
        ipv4_t                    inner_ipv4;
        ipv6_t                    inner_ipv6;
        ipv6_neighbor_discovery_t inner_ipv6_nd;
        l3l4_arp_t       inner_l3l4_arp;
        l3l4_ipv4_t      inner_l3l4_ipv4;
        l3l4_ipv6_t      inner_l3l4_ipv6;
        l3l4_nd_t        inner_l3l4_nd;
        vlan_tag_t                inner_qtag0;
        vlan_tag_t                inner_qtag1;
        tcp_t                     inner_tcp;
        timestamp_t               inner_timestamp;
        udp_t                     inner_udp;
        ipv4_t                    ipv4;
        ipv6_hbh_hel1_t           ipv6_hbh_hel1;
        ipv6_hbh_hel2_t           ipv6_hbh_hel2;
        ipv6_hbh_hel3_t           ipv6_hbh_hel3;
        ipv6_t                    ipv6;
        ipv6_hop_by_hop_t         ipv6_hop_by_hop;
        ipv6_neighbor_discovery_t ipv6_nd;
        ipv6frag_t                ipv6frag;
        ipv6srh_t                 ipv6srh;
        ipv6srh_t                 ipv6scndsrh;
        ivxlan_t                  ivxlan;
        llc_header_t              llc;
        nsh_t                     nsh;
        nsh_base_t                nsh_base;
        nsh24_t                   nsh24;
        nsh64_t                   nsh64;
        gtp_base_t                gtp_base;
        gtpv1_t                   gtpv1;
        gtpv1_ext_t               gtpv1_ext;
        gtpv2_teid_t              gtpv2_teid;
        gtpv2_t                   gtpv2;
        int_shim_int_t            int_shim_int;
        ioam_trace_ioam_t         ioam_trace_ioam;
        nsh_context_t             nsh_context;
        rocev2_ib_bth_t           rocev2_ib_bth;
        nvgre_t                   nvgre;
        l3l4_arp_t       outer_l3l4_arp;
        l3l4_ipv4_t      outer_l3l4_ipv4;
        l3l4_ipv6_t      outer_l3l4_ipv6;
        l3l4_nd_t        outer_l3l4_nd;
        vlan_tag_t                qtag0;
        vlan_tag_t                qtag1;
        snap_header_t             snap;
        tcp_t                     tcp;
        timestamp_t               timestamp;
        udp_t                     udp;
        vntag_t                   vntag;
        vxlan_gpe_t               vxlan_gpe;
        vxlan_t                   vxlan;
        vxlan_gpo_t               vxlan_gpo;
    }

    headers() hdr;
    metadata() meta;
    standard_metadata_t() standard_metadata;

    parser ParserImpl(packet_in packet, out headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
        state parse_arp {
            //meta.l3.l3_type =  4 ;
            //meta.l3.l3_type_ip =  0 ;
            packet.extract(hdr.arp_rarp);
            transition accept;
        }
        state parse_cmd {
            packet.extract(hdr.cmd);
            transition select(hdr.cmd.length_cmd) {
                8w1: parse_cmd_sgt;
                8w2 : parse_cmd_sgt_dgt;
                default: accept;
            }
        }
       
        state parse_cmd_sgt { 
            packet.extract(hdr.cmd_sgt);
            //meta.parse.cmd_valid =  1 ;
            transition select(hdr.cmd_sgt.length_sgt, hdr.cmd_sgt.optiontype_sgt, hdr.cmd_sgt.etherType) {
            (3w0, 13w1,  0x8988 ): parse_timestamp;
                (3w0, 13w1,  0x0800 ): parse_ipv4;
                (3w0, 13w1,  0x86dd ): parse_ipv6;
                (3w0, 13w1,  0x0806 ): parse_arp;
                (3w0, 13w1,  0x8035 ): parse_rarp;
                (3w0, 13w1,  0x8906 ): parse_fcoe;
                default: accept;
            }
        }
        state parse_erspan2 {
            packet.extract(hdr.erspan2);
            //meta.ig_tunnel.erspan_session = hdr.erspan2.ses;
            transition parse_inner_ethernet;
        }
        state parse_erspan3 {
            packet.extract(hdr.erspan3);
            //meta.ig_tunnel.erspan_session = hdr.erspan3.ses;
            transition parse_inner_ethernet;
        }
        
        state parse_dce{
          packet.extract(hdr.dce);
          transition parse_inner_ethernet; 
        }
        state parse_trill{
          packet.extract(hdr.trill);
          transition select(hdr.trill.oplength){ 
            5w0x0: parse_inner_ethernet;
            default: accept;
          }
        }
        state parse_ivntag {
            packet.extract(hdr.ivntag);
            transition select(hdr.ivntag.etherType) {
                 0x8100 : parse_qtag0;
                 0x88A8 : parse_qinq;
                 0x8850 : parse_cmd;
                 0x8988 : parse_timestamp;
                 0x0800 : parse_ipv4;
                 0x86dd : parse_ipv6;
                 0x0806 : parse_arp;
                 0x8035 : parse_rarp;
                 0x8906 : parse_fcoe;
                default: accept;
            }
        }
        state parse_cmd_sgt_dgt {
            packet.extract(hdr.cmd_sgt_dgt);
            meta.parse.cmd_valid =  1 ;
            transition select(hdr.cmd_sgt_dgt.length_sgt, hdr.cmd_sgt_dgt.optiontype_sgt, hdr.cmd_sgt_dgt.length_dgt, hdr.cmd_sgt_dgt.optiontype_dgt, hdr.cmd_sgt_dgt.etherType) {
                (3w0, 13w1, 3w0, 13w9,  0x8988 ): parse_timestamp;
            (3w0, 13w1, 3w0, 13w9,  0x0800 ): parse_ipv4;
            (3w0, 13w1, 3w0, 13w9,  0x86dd ): parse_ipv6;
            (3w0, 13w1, 3w0, 13w9,  0x0806 ): parse_arp;
            (3w0, 13w1, 3w0, 13w9,  0x8035 ): parse_rarp;
            (3w0, 13w1, 3w0, 13w9,  0x8906 ): parse_fcoe;
                default: accept;
            }
        }
        state parse_inner_cmd_sgt_dgt {
            packet.extract(hdr.inner_cmd_sgt_dgt);
            transition select(hdr.inner_cmd_sgt_dgt.length_sgt, hdr.inner_cmd_sgt_dgt.optiontype_sgt, hdr.inner_cmd_sgt_dgt.length_dgt, hdr.inner_cmd_sgt_dgt.optiontype_dgt, hdr.inner_cmd_sgt_dgt.etherType) {
                (3w0, 13w1, 3w0, 13w9,  0x8988 ): parse_inner_timestamp;
            (3w0, 13w1, 3w0, 13w9,  0x0800 ): parse_inner_ipv4;
            (3w0, 13w1, 3w0, 13w9,  0x86dd ): parse_inner_ipv6;
            (3w0, 13w1, 3w0, 13w9,  0x0806 ): parse_inner_arp;
            (3w0, 13w1, 3w0, 13w9,  0x8035 ): parse_inner_rarp;
            (3w0, 13w1, 3w0, 13w9,  0x8906 ): parse_inner_fcoe;
                default: accept;
            }
        }
         
        state parse_int {
            packet.extract(hdr.int_shim_int, (bit<32>)
                       (8 * ((4 * (bit<8>) (packet.lookahead<int_shim_int_up_to_len_t>().length)) - 12)));
            transition select(hdr.int_shim_int.next_proto) {
                 0x04 : parse_nsh;
                 0x03 : parse_inner_ethernet;
                default: accept;
            }
        }

        state parse_ioam {
           packet.extract(hdr.ioam_trace_ioam, (bit<32>)
                       (8 * ((4 * (bit<8>) (packet.lookahead<ioam_up_to_len_t>().len)) - 8)));
            transition select(hdr.ioam_trace_ioam.nextProto) {
                 0x04 : parse_nsh;
                 0x03 : parse_inner_ethernet;
                default: accept;
            }
        }
        state parse_nsh24 {
           packet.extract(hdr.nsh24);
           transition select(hdr.nsh_base.next_proto){
               0x01 : parse_inner_ipv4;
           0x02 : parse_inner_ipv6;
           0x03 : parse_inner_ethernet;
              default: accept;
           }
        }
        state parse_nsh64 {
           packet.extract(hdr.nsh64);
           transition select(hdr.nsh_base.next_proto){
               0x01 : parse_inner_ipv4;
           0x02 : parse_inner_ipv6;
           0x03 : parse_inner_ethernet;
              default: accept;
           }
        }
        
        state parse_ipv6srh {
            packet.extract(hdr.ipv6srh, (bit<32>)
                       (8 * (8 * (bit<8>) (packet.lookahead<ipv6srh_up_to_length_t>().hdr_ext_len - 2 ))));
        meta.l3.lkp_ip_opt = 1;
            transition select(hdr.ipv6srh.routing_type, hdr.ipv6srh.next_header) {
            (8w0xff &&& 8w0x4,  0x2b      &&& 8w0xff): parse_ipv6scndsrh;
            (8w0xff &&& 8w0x4,  0x2c      &&& 8w0xff): parse_ipv6frag;
            (8w0xff &&& 8w0x4,  0x04  &&& 8w0xff): parse_ipv4_in_ip;
            (8w0xff &&& 8w0x4,  0x29      &&& 8w0xff): parse_ipv6_in_ip;
                (8w0xff &&& 8w0x4, 8w0x3a &&& 8w0xff): parse_icmpv6;
                (8w0xff &&& 8w0x4, 8w0x11 &&& 8w0xff): parse_udp;
                (8w0xff &&& 8w0x4, 8w0x6 &&& 8w0xff): parse_tcp;
                default: accept;
            }
        }
        state parse_ipv6scndsrh {
            packet.extract(hdr.ipv6scndsrh, (bit<32>)
                       (8 * (8 * (bit<8>) (packet.lookahead<ipv6srh_up_to_length_t>().hdr_ext_len - 2))));
        meta.l3.lkp_ip_opt = 1;
            transition select(hdr.ipv6scndsrh.routing_type, hdr.ipv6scndsrh.next_header) {
            (8w0xff &&& 8w0x4,  0x2c      &&& 8w0xff): parse_ipv6frag;
            (8w0xff &&& 8w0x4,  0x04  &&& 8w0xff): parse_ipv4_in_ip;
            (8w0xff &&& 8w0x4,  0x29      &&& 8w0xff): parse_ipv6_in_ip;
                (8w0xff &&& 8w0x4, 8w0x3a &&& 8w0xff): parse_icmpv6;
                (8w0xff &&& 8w0x4, 8w0x11 &&& 8w0xff): parse_udp;
                (8w0xff &&& 8w0x4, 8w0x6 &&& 8w0xff): parse_tcp;
                default: accept;
            }
        }
        state parse_rocev2 {
          packet.extract(hdr.rocev2_ib_bth);
          transition accept; 
        }

         state parse_vxlan_gpo {
            packet.extract(hdr.vxlan_gpo);
            transition parse_inner_ethernet;
         }
         state parse_gtp_base {
          packet.extract(hdr.gtp_base);
          transition select(hdr.gtp_base.ver, hdr.gtp_base.rsvd, hdr.gtp_base.e, hdr.gtp_base.s, hdr.gtp_base.pn){
            (3w0x1,_,1w0x1,_,_): parse_gtpv1_ext;
        (3w0x1,_,_,1w0x1,_): parse_gtpv1_ext;
        (3w0x1,_,_,_,1w0x1): parse_gtpv1_ext;
        (3w0x1,_,1w0x0,1w0x0,1w0x0): parse_gtpv1;
        (3w0x2,1w0x1,_,_,_): parse_gtpv2_teid;
        (3w0x2,1w0x0,_,_,_): parse_gtpv2;
        default: accept;
          }
         }
         state parse_gtpv1 {
          packet.extract(hdr.gtpv1);
          transition accept; 
         }
         state parse_gtpv1_ext {
          packet.extract(hdr.gtpv1_ext);
          transition accept; 
         }
         state parse_gtpv2 {
          packet.extract(hdr.gtpv2);
          transition accept; 
         }

         state parse_gtpv2_teid {
          packet.extract(hdr.gtpv2_teid);
          transition accept; 
         }
        
        state parse_ethernet {
            packet.extract(hdr.ethernet);
            meta.l2.lkp_mac_sa = hdr.ethernet.srcAddr;
            meta.l2.lkp_mac_da = hdr.ethernet.dstAddr;
            transition select(hdr.ethernet.etherType) {
            
            16w0 : accept; 
                16w0 &&& 16w0xfe00: parse_llc_header;
                16w0 &&& 16w0xfa00: parse_llc_header;
            16w0 &&& 16w0xfc00: parse_llc_header;
            
             0x8903 : parse_dce;
             0x8912 : parse_trill;
             0x8926 : parse_ivntag;
            
                 0x564E : parse_vntag;
                 0x8100 : parse_qtag0;
                 0x88A8 : parse_qinq;
                 0x8850 : parse_cmd;
                 0x8988 : parse_timestamp;
                 0x0800 : parse_ipv4;
                 0x86dd : parse_ipv6;
                 0x0806 : parse_arp;
                 0x8035 : parse_rarp;
                 0x8906 : parse_fcoe;
                default: accept;
            }
        }
        state parse_ethertype_after_cmd { 
            transition select(hdr.cmd_sgt.etherType) {
                 0x8988 : parse_timestamp;
                 0x0800 : parse_ipv4;
                 0x86dd : parse_ipv6;
                 0x0806 : parse_arp;
                 0x8035 : parse_rarp;
                 0x8906 : parse_fcoe;
                default: accept;
            }
        }
        state parse_ethertype_after_inner_cmd_sgt { 
            transition select(hdr.inner_cmd_sgt.etherType) {
                 0x8988 : parse_inner_timestamp;
                 0x0800 : parse_inner_ipv4;
                 0x86dd : parse_inner_ipv6;
                 0x0806 : parse_inner_arp;
                 0x8035 : parse_inner_rarp;
                 0x8906 : parse_inner_fcoe;
                default: accept;
            }
        }
        state parse_fcoe {
            packet.extract(hdr.fcoe);
            transition accept;
        }
        state parse_geneve {
            packet.extract(hdr.geneve, (bit<32>)
                       (8 * 4 * (bit<6>) (packet.lookahead<geneve_up_to_len_t>().optLen))); 
            meta.ig_tunnel.src_vnid = hdr.geneve.vni;
            meta.ig_tunnel.src_encap_type =  4 ;
            meta.ig_tunnel.src_l3_encap_type =  1 ;
            transition select(hdr.geneve.ver, hdr.geneve.protoType) {
        
                (2w0x0,  0x6558 ): parse_inner_ethernet;
                (2w0x0,  0x0800 ): parse_inner_ipv4;
                (2w0x0,  0x86dd ): parse_inner_ipv6;
            (2w0x0,  0x894f ):  parse_nsh;      
                default: accept;
            }
        }
        state parse_gre {
            packet.extract(hdr.gre);
            transition select(hdr.gre.C, hdr.gre.R, hdr.gre.K, hdr.gre.S, hdr.gre.s, hdr.gre.recurse, hdr.gre.flags, hdr.gre.ver, hdr.gre.proto) {
                (1w0x0, 1w0x0, 1w0x0, 1w0x0, 1w0x0, 3w0x0, 5w0x0, 3w0x0,  0x0800 ): parse_gre_ipv4;
                (1w0x0, 1w0x0, 1w0x0, 1w0x0, 1w0x0, 3w0x0, 5w0x0, 3w0x0,  0x86dd ): parse_gre_ipv6;
                (1w0x0, 1w0x0, 1w0x1, 1w0x0, 1w0x0, 3w0x0, 5w0x0, 3w0x0,  0x6558 ): parse_nvgre;
                (1w0x0, 1w0x0, 1w0x0, 1w0x0, 1w0x0, 3w0x0, 5w0x0, 3w0x0,  0x88BE  ): parse_erspan2;
                (1w0x0, 1w0x0, 1w0x0, 1w0x0, 1w0x0, 3w0x0, 5w0x0, 3w0x0,  0x22EB  ): parse_erspan3;
                (1w0x0, 1w0x0, 1w0x0, 1w0x0, 1w0x0, 3w0x0, 5w0x0, 3w0x0,  0x894f ): parse_nsh;
                default: accept;
            }
        }
        state parse_gre_ipv4 {
            meta.ig_tunnel.src_encap_pkt =  1 ;
            meta.ig_tunnel.src_encap_type =  2 ;
            meta.ig_tunnel.src_l3_encap_type =  1 ;
            transition parse_inner_ipv4;
        }
        state parse_gre_ipv6 {
            meta.ig_tunnel.src_encap_pkt =  1 ;
            meta.ig_tunnel.src_encap_type =  2 ;
            meta.ig_tunnel.src_l3_encap_type =  1 ;
            transition parse_inner_ipv6;
        }
        state parse_icmp {
            packet.extract(hdr.icmp);
            meta.l3.lkp_l4_sport = hdr.icmp.typeCode;
            transition select(hdr.icmp.typeCode) {
                default: accept;
            }
        }
        state parse_icmpv6 {
            packet.extract(hdr.icmpv6);
            meta.l3.l4_type =  15 ;
            transition select(hdr.icmpv6.code, hdr.icmpv6.type_) {
                (8w0,  135 ): parse_ipv6_nd;
                (8w0,  136 ): parse_ipv6_nd;
                default: accept;
            }
        }
        state parse_ieth_tag {
            packet.extract(hdr.ieth);
            transition select(hdr.ieth.etherType) {
                 0x564E : parse_vntag;
                 0x8100 : parse_qtag0;
                 0x88A8 : parse_qinq;
                 0x8850 : parse_cmd;
                 0x8988 : parse_timestamp;
                 0x0800 : parse_ipv4;
                 0x86dd : parse_ipv6;
                 0x0806 : parse_arp;
                 0x8035 : parse_rarp;
                 0x8906 : parse_fcoe;
                default: accept;
            }
        }
        state parse_inner_arp {
            packet.extract(hdr.inner_arp_rarp);
            meta.l3.inner_l3_type =  4 ;
            meta.l3.inner_l3_type_ip =  0 ;
            transition accept;
        }
        state parse_inner_cmd {
            packet.extract(hdr.inner_cmd);
            transition select(hdr.inner_cmd.length_cmd) {
                8w1: parse_inner_cmd_sgt;
            8w2: parse_inner_cmd_sgt_dgt;
            default: accept;
            }
        }
        state parse_inner_cmd_sgt {
            packet.extract(hdr.inner_cmd_sgt);
            transition select(hdr.inner_cmd_sgt.length_sgt, hdr.inner_cmd_sgt.optiontype_sgt, hdr.inner_cmd_sgt.etherType) {
                (3w0, 13w1, 0x8988 ): parse_inner_timestamp;
            (3w0, 13w1, 0x0800 ): parse_inner_ipv4;
            (3w0, 13w1, 0x86dd ): parse_inner_ipv6;
            (3w0, 13w1, 0x0806 ): parse_inner_arp;
            (3w0, 13w1, 0x8035 ): parse_inner_rarp;
            (3w0, 13w1, 0x8906 ): parse_inner_fcoe;
            default:accept;
            }
        }
        state parse_inner_ethernet {
            packet.extract(hdr.inner_ethernet);
            transition select(hdr.inner_ethernet.etherType) {
                 0x8100 : parse_inner_vlan0;
                 0x8850 : parse_inner_cmd;
                 0x8988 : parse_inner_timestamp;
                 0x0800 : parse_inner_ipv4;
                 0x86dd : parse_inner_ipv6;
                 0x0806 : parse_inner_arp;
                 0x8035 : parse_inner_rarp;
                 0x8906 : parse_inner_fcoe;
                default: accept;
            }
        }
        state parse_inner_fcoe {
            packet.extract(hdr.inner_fcoe);
            transition accept;
        }
        state parse_inner_icmp {
            packet.extract(hdr.inner_icmp);
            meta.l3.lkp_inner_l4_sport = hdr.inner_icmp.typeCode;
            transition accept;
        }
        state parse_inner_icmpv6 {
            packet.extract(hdr.inner_icmpv6);
            meta.l3.inner_l4_type =  15 ;
            transition select(hdr.inner_icmpv6.code, hdr.inner_icmpv6.type_) {
                (8w0,  135 ): parse_inner_ipv6_nd;
                (8w0,  136 ): parse_inner_ipv6_nd;
                default: accept;
            }
        }
        state parse_inner_ipv4 {
            packet.extract(hdr.inner_ipv4, (bit<32>)
                        (8 *
                         (4 * (bit<9>) (packet.lookahead<ipv4_up_to_ihl_only_t >().ihl)- 20)));
            meta.l3.inner_l3_type =  1 ;
            meta.l3.inner_l3_type_ip =  1 ;
            transition select(hdr.inner_ipv4.fragOffset, hdr.inner_ipv4.ihl, hdr.inner_ipv4.protocol) {
                (13w0x0, 4w0x5,  1 ): parse_inner_icmp;
                (13w0x0, 4w0x5,  6 ): parse_inner_tcp;
                (13w0x0, 4w0x5,  17 ): parse_inner_udp;
                default: accept;
            }
        }
        state parse_inner_ipv6 {
            packet.extract(hdr.inner_ipv6);
            meta.l3.inner_l3_type =  2 ;
            meta.l3.inner_l3_type_ip =  1 ;
            transition select(hdr.inner_ipv6.nextHeader) {
                 58 : parse_inner_icmpv6;
                 6 : parse_inner_tcp;
                 17 : parse_inner_udp;
                default: accept;
            }
        }
        state parse_inner_ipv6_nd {
            packet.extract(hdr.inner_ipv6_nd);
            meta.l3.inner_l4_type =  8 ;
            transition accept;
        }
        state parse_inner_rarp {
            packet.extract(hdr.inner_arp_rarp);
            meta.l3.inner_l3_type =  5 ;
            meta.l3.inner_l3_type_ip =  0 ;
            transition accept;
        }
        state parse_inner_tcp {
            packet.extract(hdr.inner_tcp);
            meta.l3.lkp_inner_l4_sport = hdr.inner_tcp.srcPort;
            meta.l3.lkp_inner_l4_dport = hdr.inner_tcp.dstPort;
            meta.l3.lkp_inner_tcp_flags = hdr.inner_tcp.flags;
            transition accept;
        }
        state parse_inner_timestamp {
            packet.extract(hdr.inner_timestamp);
            transition select(hdr.inner_timestamp.etherType) {
                 0x0800 : parse_inner_ipv4;
                 0x86dd : parse_inner_ipv6;
                 0x0806 : parse_inner_arp;
                 0x8035 : parse_inner_rarp;
                 0x8906 : parse_inner_fcoe;
                default: accept;
            }
        }
        state parse_inner_udp {
            packet.extract(hdr.inner_udp);
            meta.l3.lkp_inner_l4_sport = hdr.inner_udp.srcPort;
            meta.l3.lkp_inner_l4_dport = hdr.inner_udp.dstPort;
            transition accept;
        }
        state parse_inner_vlan0 {
            packet.extract(hdr.inner_qtag0);
            meta.parse.inner_qtag_valid =  1 ;
            transition select(hdr.inner_qtag0.etherType) {
                 0x8850 : parse_inner_cmd;
                 0x8988 : parse_inner_timestamp;
                 0x0800 : parse_inner_ipv4;
                 0x86dd : parse_inner_ipv6;
                 0x0806 : parse_inner_arp;
                 0x8035 : parse_inner_rarp;
                 0x8906 : parse_inner_fcoe;
                default: accept;
            }
        }
        state parse_ipv4 {
            packet.extract(hdr.ipv4,(bit<32>)
                          (8 *
                          (4 * (bit<9>) (packet.lookahead<ipv4_up_to_ihl_only_t >().ihl)- 20)));
            meta.ipv4m.lkp_ipv4_sa = hdr.ipv4.srcAddr;
            meta.ipv4m.lkp_ipv4_da = hdr.ipv4.dstAddr;
            meta.l3.l3_type =  1 ;
            meta.l3.l3_type_ip =  1 ;
            meta.l3.lkp_ip_proto = hdr.ipv4.protocol;
            meta.l3.lkp_ip_ttl = hdr.ipv4.ttl;
            meta.l3.lkp_ip_dscp = hdr.ipv4.dscp;
            meta.l3.lkp_ip_ecn = hdr.ipv4.ecn;
            meta.l3.lkp_ip_len = hdr.ipv4.totalLen;
            meta.l3.lkp_ip_fragOffset = hdr.ipv4.fragOffset;
            meta.l3.lkp_ip_flag_more = hdr.ipv4.flag_more;
        meta.l3.lkp_ip_opt = 0;
            transition select(hdr.ipv4.version, hdr.ipv4.ihl, hdr.ipv4.flag_rsvd, hdr.ipv4.flag_noFrag, hdr.ipv4.flag_more, hdr.ipv4.fragOffset, hdr.ipv4.protocol) { 
                (4w0x4 &&& 4w0xf, 4w0x5 &&& 4w0xf, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 13w0x0 &&& 13w0x1fff, 8w0x2f &&& 8w0xff): parse_gre;
                (4w0x4 &&& 4w0xf, 4w0x5 &&& 4w0xf, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 13w0x0 &&& 13w0x1fff, 8w0x4 &&& 8w0xff): parse_ipv4_in_ip;
                (4w0x4 &&& 4w0xf, 4w0x5 &&& 4w0xf, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 13w0x0 &&& 13w0x1fff, 8w0x29 &&& 8w0xff): parse_ipv6_in_ip;
                (4w0x4 &&& 4w0xf, 4w0x5 &&& 4w0xf, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 13w0x0 &&& 13w0x1fff, 8w0x11 &&& 8w0xff): parse_udp;
                (4w0x4 &&& 4w0xf, 4w0x5 &&& 4w0xf, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 13w0x0 &&& 13w0x1fff, 8w0x1 &&& 8w0xff): parse_icmp;
                (4w0x4 &&& 4w0xf, 4w0x5 &&& 4w0xf, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 13w0x0 &&& 13w0x1fff, 8w0x6 &&& 8w0xff): parse_tcp;
                (4w0x4 &&& 4w0xf, 4w0x0 &&& 4w0x0, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 1w0x0 &&& 1w0x0, 13w0x0 &&& 13w0x0, 8w0x0 &&& 8w0x0): accept;
            }
        }
        state parse_ipv4_in_ip {
            meta.ig_tunnel.src_encap_pkt =  1 ;
            meta.ig_tunnel.src_encap_type =  3 ;
            meta.ig_tunnel.src_l3_encap_type =  1 ;
            transition parse_inner_ipv4;
        }
        state parse_ipv6 {
            packet.extract(hdr.ipv6);
            meta.ipv6m.lkp_ipv6_sa = hdr.ipv6.srcAddr;
            meta.ipv6m.lkp_ipv6_da = hdr.ipv6.dstAddr;
            meta.l3.l3_type =  2 ;
            meta.l3.l3_type_ip =  1 ;
            meta.l3.lkp_ip_proto = hdr.ipv6.nextHeader;
            meta.l3.lkp_ip_ttl = hdr.ipv6.hopLimit;
            meta.l3.lkp_ip_dscp = hdr.ipv6.dscp;
            meta.l3.lkp_ip_ecn = hdr.ipv6.ecn;
            meta.l3.lkp_ip_len = hdr.ipv6.payloadLen;
        meta.l3.lkp_ip_opt = 0;
            transition select(hdr.ipv6.nextHeader) {
                 0x06 : parse_tcp;
                 0x11    : parse_udp;
                 0x3a    : parse_icmp;
                 0x2f    : parse_gre;
                 0x04 : parse_ipv4_in_ip;
                 0x29    : parse_ipv6_in_ip;
                 0x00 : parse_ipv6_hop_by_hop;
                 0x2c    : parse_ipv6frag;
             0x2b    : parse_ipv6srh;
                default: accept;
            }
        }
        state parse_ipv6_hop_by_hop {
            packet.extract(hdr.ipv6_hop_by_hop);
        meta.l3.lkp_ip_opt = 1;
            transition select(hdr.ipv6_hop_by_hop.protocol) {
                 58 : parse_icmpv6;
                 17 : parse_udp;
                 6 : parse_tcp;
             43 : parse_ipv6srh;
                 44 : parse_ipv6frag;
                default: accept;
            }
        }
        state parse_ipv6_in_ip {
            meta.ig_tunnel.src_encap_pkt =  1 ;
            meta.ig_tunnel.src_encap_type =  3 ;
            meta.ig_tunnel.src_l3_encap_type =  1 ;
            transition parse_inner_ipv6;
        }
        state parse_ipv6_nd {
            packet.extract(hdr.ipv6_nd);
            meta.l3.l4_type =  8 ;
            transition accept;
        }
        state parse_ipv6frag {
            packet.extract(hdr.ipv6frag);
            meta.l3.lkp_ip_flag_more = hdr.ipv6frag.flag_more;
            meta.l3.lkp_ip_fragOffset = hdr.ipv6frag.fragOffset;
        meta.l3.lkp_ip_opt = 1;
            transition select(hdr.ipv6frag.flag_more, hdr.ipv6frag.fragOffset, hdr.ipv6frag.protocol) {
                (1w0x0 &&& 1w0x0, 13w0x0 &&& 13w0x1fff, 8w0x3a &&& 8w0xff): parse_icmpv6;
                (1w0x0 &&& 1w0x0, 13w0x0 &&& 13w0x0, 8w0x11 &&& 8w0xff): parse_udp;
                (1w0x0 &&& 1w0x0, 13w0x0 &&& 13w0x0, 8w0x6 &&& 8w0xff): parse_tcp;      
                default: accept;
            }
        }
        
        state parse_ivxlan {
            packet.extract(hdr.ivxlan);
            meta.ig_tunnel.src_encap_pkt =  1 ;
            meta.ig_tunnel.src_encap_type =  14 ;
            meta.ig_tunnel.src_l3_encap_type =  1 ;
            meta.ig_tunnel.src_vnid = hdr.ivxlan.vni;
            transition parse_inner_ethernet;
        }
        state parse_llc_header {
            packet.extract(hdr.llc);
            transition select(hdr.llc.dsap, hdr.llc.ssap, hdr.llc.control_, hdr.llc.oui) {
                (8w0xaa, 8w0xaa, 8w0x03, 24w0x0): parse_snap_header;
                default: accept;
            }
        }
        state parse_nsh {
            packet.extract(hdr.nsh_base);
        
            transition select(hdr.nsh_base.md_type, hdr.nsh_base.length) {
            (8w0, 6w6): parse_nsh24;
            (8w1, 6w6): parse_nsh24;
            (8w0, 6w16): parse_nsh64;
            (8w1, 6w16): parse_nsh64;
            default: accept;
         }
               
        }
        state parse_nvgre {
            packet.extract(hdr.nvgre);
            meta.ig_tunnel.src_encap_type =  5 ;
            meta.ig_tunnel.src_l3_encap_type =  1 ;
            meta.ig_tunnel.src_vnid = hdr.nvgre.tni;
            transition parse_inner_ethernet;
        }
        state parse_qinq {
            packet.extract(hdr.qtag0);
            meta.parse.qtag_valid =  1 ;
            transition select(hdr.qtag0.etherType) {
                 0x8100 : parse_qtag1;
                default: accept;
            }
        }
        state parse_qtag0 {
            packet.extract(hdr.qtag0);
            meta.parse.qtag_valid =  1 ;
            transition select(hdr.qtag0.etherType) {
            
             0x8912 : parse_trill;
            
                 0x8850 : parse_cmd;
                 0x8100 : parse_qtag1;
                 0x8988 : parse_timestamp;
                 0x0800 : parse_ipv4;
                 0x86dd : parse_ipv6;
                 0x0806 : parse_arp;
                 0x8035 : parse_rarp;
                 0x8906 : parse_fcoe;
                default: accept;
            }
        }
        state parse_qtag1 {
            packet.extract(hdr.qtag1);
            meta.parse.qinq_tag_valid =  1 ;
            transition select(meta.parse.cmd_valid, hdr.qtag1.etherType) {
                (1w0x1,  0x8850 ): accept;
                (1w0x0,  0x8850 ): parse_cmd;
                (1w0x0 &&& 1w0x0,  0x8988 ): parse_timestamp;
                (1w0x0 &&& 1w0x0,  0x0800 ): parse_ipv4;
                (1w0x0 &&& 1w0x0,  0x86dd ): parse_ipv6;
                (1w0x0 &&& 1w0x0,  0x0806 ): parse_arp;
                (1w0x0 &&& 1w0x0,  0x8035 ): parse_rarp;
                (1w0x0 &&& 1w0x0,  0x8906 ): parse_fcoe;
                default: accept;
            }
        }
        state parse_rarp {
            meta.l3.l3_type =  5 ;
            meta.l3.l3_type_ip =  0 ;
            packet.extract(hdr.arp_rarp);
            transition accept;
        }
        state parse_snap_header { 
            packet.extract(hdr.snap);
            transition select(hdr.snap.type_) {
               
                 0x0800 : parse_ipv4;
                 0x86dd : parse_ipv6;
                 0x0806 : parse_arp;
                 0x8035 : parse_rarp;
                 0x8906 : parse_fcoe;
                default: accept;
            }
        }
        state parse_tcp {
            packet.extract(hdr.tcp);
            meta.l3.l4_type =  0 ;
            meta.l3.lkp_l4_sport = hdr.tcp.srcPort;
            meta.l3.lkp_l4_dport = hdr.tcp.dstPort;
            meta.l3.lkp_tcp_flags = hdr.tcp.flags;
            transition select(hdr.tcp.dstPort) {
             3386 : parse_gtp_base;
                default: accept;
            }
        }
        state parse_timestamp {
            packet.extract(hdr.timestamp);
            transition select(hdr.timestamp.etherType) {
                 0x0800 : parse_ipv4;
                 0x86dd : parse_ipv6;
                 0x0806 : parse_arp;
                 0x8035 : parse_rarp;
                 0x8906 : parse_fcoe;
                default: accept;
            }
        }
        
        state parse_udp {
            packet.extract(hdr.udp);
            meta.l3.l4_type =  1 ;
            meta.l3.lkp_l4_sport = hdr.udp.srcPort;
            meta.l3.lkp_l4_dport = hdr.udp.dstPort;
        
            transition select(meta.l3.lkp_ip_opt,hdr.udp.dstPort) {
            (1w0x0, 4788  ): parse_vxlan_gpo;
                (1w0x0, 4789 ): parse_vxlan;
                (1w0x0, 0xBEEF ): parse_ivxlan;
                (1w0x0, 6081 ): parse_geneve;
                (1w0x0, 4790 ): parse_vxlan_gpe;
            (1w0x0, 4791  ): parse_rocev2;
            (1w0x0, 3386  ): parse_gtp_base;
                
                default: accept;
            }
        }
        state parse_vntag {
            packet.extract(hdr.vntag);
            transition select(hdr.vntag.etherType) {
                 0x8100 : parse_qtag0;
                 0x88A8 : parse_qinq;
                 0x8850 : parse_cmd;
                 0x8988 : parse_timestamp;
                 0x0800 : parse_ipv4;
                 0x86dd : parse_ipv6;
                 0x0806 : parse_arp;
                 0x8035 : parse_rarp;
                 0x8906 : parse_fcoe;
                default: accept;
            }
        }
        state parse_vxlan {
            packet.extract(hdr.vxlan);
            meta.ig_tunnel.src_encap_pkt =  1 ;
            meta.ig_tunnel.src_encap_type =  1 ;
            meta.ig_tunnel.src_l3_encap_type =  1 ;
            meta.ig_tunnel.src_vnid = hdr.vxlan.vni;
            transition parse_inner_ethernet;
        }
        state parse_vxlan_gpe {
            packet.extract(hdr.vxlan_gpe);
            meta.ig_tunnel.src_encap_type =  8 ;
            meta.ig_tunnel.src_l3_encap_type =  1 ;
            meta.ig_tunnel.src_vnid = hdr.vxlan_gpe.vni;
            transition select(hdr.vxlan_gpe.flags_p, hdr.vxlan_gpe.next_proto) {
                (1w0x1, 8w0x1): parse_inner_ipv4;
                (1w0x1, 8w0x2): parse_inner_ipv6;
                (1w0x1, 8w0x3): parse_inner_ethernet;
                (1w0x1, 8w0x4): parse_nsh;
            (1w0x1, 8w0x5): parse_int;
            (1w0x1, 8w0x6): parse_ioam; 
                default: parse_inner_ethernet;
            }
        }
        state start {
            transition parse_ethernet;
        }
    }

    control ingress(inout headers hdr, inout metadata meta, inout standard_metadata_t standard_metadata) {
        @name("NoAction") action NoAction() {
        }
        @name("action1") action action1(bit<24> ptr) {
            meta.fwd_metadata.l2ptr = ptr;
        }
        @name("action2") action action2(bit<24> bd) {
            meta.fwd_metadata.out_bd = bd;
        }
        @name("action3") action action3(bit<32> dst_adr) {
            hdr.ipv4.dstAddr = dst_adr;
        }
        @name("action4") action action4(bit<32> src_adr) {
            hdr.ipv4.srcAddr = src_adr;
        }
        @name("action5") action action5(bit<16> ipv6_payloadLen) {
            hdr.ipv6.payloadLen = ipv6_payloadLen;
        }
        @name("action6") action action6(bit<16> tcp_srcPort) {
            hdr.tcp.srcPort = tcp_srcPort;
        }
        @name("action7") action action7(bit<16> udp_srcPort) {
            hdr.udp.srcPort = udp_srcPort;
        }

        @name("table1") table table1 {
            actions = {
                action1;
                @default_only NoAction;
            }
            key = {
                hdr.ethernet.dstAddr: ternary;
            }
            default_action = NoAction();
        }
        @name("table2") table table2 {
            actions = {
                action2;
                @default_only NoAction;
            }
            key = {
                hdr.ethernet.srcAddr: ternary;
            }
            default_action = NoAction();
        }
        @name("table3") table table3 {
            actions = {
                action3;
                @default_only NoAction;
            }
            key = {
                meta.fwd_metadata.l2ptr: ternary;
            }
            default_action = NoAction();
        }
        @name("table4") table table4 {
            actions = {
                action4;
                @default_only NoAction;
            }
            key = {
                meta.fwd_metadata.out_bd: ternary;
            }
            default_action = NoAction();
        }
        @name("table5") table table5 {
            actions = {
                action5;
                @default_only NoAction;
            }
            key = {
                hdr.ethernet.srcAddr: ternary;
            }
            default_action = NoAction();
        }
        @name("table6") table table6 {
            actions = {
                action6;
                @default_only NoAction;
            }
            key = {
                hdr.ethernet.srcAddr: ternary;
            }
            default_action = NoAction();
        }
        @name("table7") table table7 {
            actions = {
                action7;
                @default_only NoAction;
            }
            key = {
                hdr.ethernet.srcAddr: ternary;
            }
            default_action = NoAction();
        }
        apply {
            table1.apply();
            table2.apply();
            if(hdr.ipv4.isValid()){
     	    if(hdr.ipv4.srcAddr != hdr.ipv4.dstAddr){
        	        table3.apply();
    	    }
                table4.apply();
            }

            if(hdr.ipv6.isValid()){
                table5.apply();
            }
            if(hdr.tcp.isValid()){
                table6.apply();
            }
            if(hdr.udp.isValid()){
                table7.apply();
            }
        }
    }

    control DeparserImpl(packet_out packet, in headers hdr) {
        apply {
            packet.emit(hdr.ethernet);
            packet.emit(hdr.ipv4);
            packet.emit(hdr.tcp);
        }
    }

    control verifyChecksum(in headers hdr, inout metadata meta) {
        apply {
        }
    }

    control computeChecksum(inout headers hdr, inout metadata meta) {
        apply {
        }
    }

    V1Switch(ParserImpl(), verifyChecksum(), ingress(), egress(), computeChecksum(), DeparserImpl()) main;

